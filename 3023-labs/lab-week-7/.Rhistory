?rbinom
samples = 1000
size = 200
p = 0.3
X = rbinom(samples, size, p)
X
samples = 1000
size = 200
p = 0.3
X = rbinom(samples, size, p)
X
hist(X)
samples = 1000
size = 200
p = 0.3
X = rbinom(samples, size, p)
hist(X)
?pnorm
dnorm(1)
pnorm(0)
dnorm(0)
1/sqrt(2*pi)*exp(-1/2 * (0)^2)
samples = 1000
size = 200
p = 0.3
X = rbinom(samples, size, p)
hist(X, prob = TRUE, main = "Distribution of the bin(200, 0.3)")
X_mean = size * p
X_sd = sqrt(size * p * (1 - p))
curve(dnorm(x, mean = X_mean, sd = X_sd), xlim = c(0, 200), add = TRUE)
pbinom(55, size, p) - pbinom(45, size, p)
pnorm(55.5, mean = X_mean, sd = X_sd) - pnorm(45.5, mean = X_mean, sd = X_sd)
?rbinom
?poisson
?dpois
?rbinom
?hist
simulations = 1000
size = 200
p = 0.3
lambda = 6
# 1000 draws of a binomial distribution
X = rbinom(simulations, size, p)
# 1000 draws of a poisson distribution
Y = rpois(similations, lambda)
# plot with 1 row and 2 columns
par(mfrow=c(1,2)
# Historgrams of X and Y
hist(X, probability = TRUE, main = "binomial distribution")
hist(Y, probability = TRUE, main = "Poisson distribution")
samples = 1000
size = 200
p = 0.3
X = rbinom(samples, size, p)
hist(X, prob = TRUE, main = "Distribution of the bin(200, 0.3)")
X_mean = size * p
X_sd = sqrt(size * p * (1 - p))
curve(dnorm(x, mean = X_mean, sd = X_sd), xlim = c(0, 200), add = TRUE)
simulations = 1000
size = 200
p = 0.3
lambda = 6
# 1000 draws of a binomial distribution
X = rbinom(simulations, size, p)
# 1000 draws of a poisson distribution
Y = rpois(similations, lambda)
# 1000 draws of a poisson distribution
Y = rpois(simiulations, lambda)
# plot with 1 row and 2 columns
# Historgrams of X and Y
hist(X, probability = TRUE, main = "binomial distribution")
hist(Y, probability = TRUE, main = "Poisson distribution")
# Historgrams of X and Y
hist(X, probability = TRUE, main = "binomial distribution")
# 1000 draws of a poisson distribution
Y = rpois(simiulations, lambda)
# 1000 draws of a poisson distribution
Y = rpois(simulations, lambda)
# plot with 1 row and 2 columns
# Historgrams of X and Y
hist(X, probability = TRUE, main = "binomial distribution")
hist(Y, probability = TRUE, main = "Poisson distribution")
?pbinom
?ppois
?runif
?matrix
?apply
?par
?mfrow
?hist
?curve
sim_number = 1000
n1 = 5
n2 = 100
mu = 1/2
sigma_squared = 1/12
# sample from the uniform distribution n1 times and repeat the experiment
# sim_number of times
temp1 = runif(sim_number * n1, min = 0, max = 1)
sim1 = matrix(data = temp1, nrow = n1, ncol = sim_number)
sim1 = sim1 - mu
S1 = apply(sim1, MARGIN = 1, FUN = sum)/sqrt(n1 * sigma_squared)
# sample from the uniform distribution n2 times and repeat the experiment
# sim_number of times
temp2 = runif(sim_number * n2, min = 0, max = 1)
sim2 = matrix(data = temp2, nrow = n2, ncol = sim_number)
sim2 = sim2 - mu
S2 = apply(sim2, MARGIN = 1, FUN = sum)/sqrt(n2 * sigma_squared)
par(mfrow = c(1, 2))
hist(S1)
curve(dnorm(x, mean = 0, sd = 1), xlim = c(-3, 3))
sim_number = 1000
n1 = 5
n2 = 100
mu = 1/2
sigma_squared = 1/12
# sample from the uniform distribution n1 times and repeat the experiment
# sim_number of times
temp1 = runif(sim_number * n1, min = 0, max = 1)
sim1 = matrix(data = temp1, nrow = n1, ncol = sim_number)
sim1 = sim1 - mu
S1 = apply(sim1, MARGIN = 1, FUN = sum)/sqrt(n1 * sigma_squared)
# sample from the uniform distribution n2 times and repeat the experiment
# sim_number of times
temp2 = runif(sim_number * n2, min = 0, max = 1)
sim2 = matrix(data = temp2, nrow = n2, ncol = sim_number)
sim2 = sim2 - mu
S2 = apply(sim2, MARGIN = 1, FUN = sum)/sqrt(n2 * sigma_squared)
par(mfrow = c(1, 2))
hist(S1)
curve(dnorm(x, mean = 0, sd = 1), xlim = c(-3, 3), add = TRUE)
sim_number = 1000
n1 = 5
n2 = 100
mu = 1/2
sigma_squared = 1/12
# sample from the uniform distribution n1 times and repeat the experiment
# sim_number of times
temp1 = runif(sim_number * n1, min = 0, max = 1)
sim1 = matrix(data = temp1, nrow = n1, ncol = sim_number)
sim1 = sim1 - mu
S1 = apply(sim1, MARGIN = 1, FUN = sum)/sqrt(n1 * sigma_squared)
# sample from the uniform distribution n2 times and repeat the experiment
# sim_number of times
temp2 = runif(sim_number * n2, min = 0, max = 1)
sim2 = matrix(data = temp2, nrow = n2, ncol = sim_number)
sim2 = sim2 - mu
S2 = apply(sim2, MARGIN = 1, FUN = sum)/sqrt(n2 * sigma_squared)
par(mfrow = c(1, 2))
hist(S1, probability = TRUE)
curve(dnorm(x, mean = 0, sd = 1), xlim = c(-3, 3), add = TRUE)
sim_number = 1000
n1 = 5
n2 = 100
mu = 1/2
sigma_squared = 1/12
# sample from the uniform distribution n1 times and repeat the experiment
# sim_number of times
temp1 = runif(sim_number * n1, min = 0, max = 1)
sim1 = matrix(data = temp1, nrow = n1, ncol = sim_number)
sim1 = sim1 - mu
S1 = apply(sim1, MARGIN = 1, FUN = sum)/sqrt(n1 * sigma_squared)
# sample from the uniform distribution n2 times and repeat the experiment
# sim_number of times
temp2 = runif(sim_number * n2, min = 0, max = 1)
sim2 = matrix(data = temp2, nrow = n2, ncol = sim_number)
sim2 = sim2 - mu
S2 = apply(sim2, MARGIN = 1, FUN = sum)/sqrt(n2 * sigma_squared)
par(mfrow = c(1, 2))
hist(S1, probability = TRUE)
curve(dnorm(x, mean = 0, sd = 1), add = TRUE)
set.seed(3023)
sim_number = 1000
n1 = 5
n2 = 100
mu = 1/2
sigma_squared = 1/12
# sample from the uniform distribution n1 times and repeat the experiment
# sim_number of times
temp1 = (runif(sim_number * n1) - mu)/sqrt(n1 * sigma_squared)
mat_temp1 = matrix(temp1, ncol = n1)
dim(mat_temp1)
set.seed(3023)
sim_number = 1000
n1 = 5
n2 = 100
mu = 1/2
sigma_squared = 1/12
# sample from the uniform distribution n1 times and repeat the experiment
# sim_number of times
temp1 = (runif(sim_number * n1) - mu)/sqrt(n1 * sigma_squared)
mat_temp1 = matrix(temp1, ncol = n1)
dim(mat_temp1)
S1 = apply(mate_temp1, 1, sum)
set.seed(3023)
sim_number = 1000
n1 = 5
n2 = 100
mu = 1/2
sigma_squared = 1/12
# sample from the uniform distribution n1 times and repeat the experiment
# sim_number of times
temp1 = (runif(sim_number * n1) - mu)/sqrt(n1 * sigma_squared)
mat_temp1 = matrix(temp1, ncol = n1)
dim(mat_temp1)
S1 = apply(mat_temp1, 1, sum)
set.seed(3023)
sim_number = 1000
n1 = 5
n2 = 100
mu = 1/2
sigma_squared = 1/12
# sample from the uniform distribution n1 times and repeat the experiment
# sim_number of times
temp1 = (runif(sim_number * n1) - mu)/sqrt(n1 * sigma_squared)
mat_temp1 = matrix(temp1, ncol = n1)
dim(mat_temp1)
S1 = apply(mat_temp1, 1, sum)
hist(S1, probability = TRUE)
set.seed(3023)
sim_number = 1000
n1 = 5
n2 = 100
mu = 1/2
sigma_squared = 1/12
# sample from the uniform distribution n1 times and repeat the experiment
# sim_number of times
temp1 = (runif(sim_number * n1) - mu)/sqrt(n1 * sigma_squared)
mat_temp1 = matrix(temp1, ncol = n1)
dim(mat_temp1)
S1 = apply(mat_temp1, 1, sum)
hist(S1, probability = TRUE)
curve(dnorm(x), add = TRUE)
a = qexp(0.025)
b = qexp(0.975)
c(a, b)
?qexp
?ablione
?abline
th = (250:1500)/1000
power =  pexp(a, rate = 1, lower.tail = TRUE) + pexp(b, rate = 1, lower.tail = FALSE)
# Plot theta against the power:
plot(th, power, type = "l", main = "Power of two tail test")
# add a horizontal dashed line at gamma = 0.05
abline(h = 0.05, lty = 2)
a = qexp(0.025, rate = 1)
b = qexp(0.975, rate = 1)
c(a, b)
power =  pexp(a, rate = 1, lower.tail = TRUE) + pexp(b, rate = 1, lower.tail = FALSE)
# Plot theta against the power:
plot(th, power, type = "l", main = "Power of two tail test")
power =  pexp(a, rate = th, lower.tail = TRUE) + pexp(b, rate = th, lower.tail = FALSE)
# Plot theta against the power:
plot(th, power, type = "l", main = "Power of two tail test")
# add a horizontal dashed line at gamma = 0.05
abline(h = 0.05, lty = 2)
th = (250:1500)/1000
power =  pexp(a, rate = 1/th, lower.tail = TRUE) + pexp(b, rate = 1/th, lower.tail = FALSE)
# Plot theta against the power:
plot(th, power, type = "l", main = "Power of two tail test")
# add a horizontal dashed line at gamma = 0.05
abline(h = 0.05, lty = 2)
fn = function(c, alpha) {
term = alpha - 1 + exp(-1 * c)
return(c * exp(-c) + (log(term) * term))
}
?uniroot
eps = 1e-5
uniroot(f = fn, lower = 0, upper = qexp(0.05), alpha = 0.05)
fn = function(c, alpha) {
term = alpha - 1 + exp(-1 * c)
return(c * exp(-c) + (log(term) * term))
}
eps = 1e-5
uniroot(f = fn, lower = 0, upper = qexp(0.05), alpha = 0.05)
uniroot(f = fn, lower = 0, upper = qexp(0.05) - eps, alpha = 0.05)
expon.umpu = function(alpha) {
eps = 1e-8
c = uniroot(f = fn, lower = 0, upper = qexp(alpha) - eps, alpha = alpha)$root
term = alpha - 1 + exp(-c)
d = -log(term)
list(c_val = c, d_val = d)
}
expon.umpu(0.05)
th = (250:1500)/1000
# for the two tailed test
power = pexp(a, 1/th) + pexp(b, 1/th, lower.tail = FALSE)
plot(th, power, type = "l", main = "testing for an exponential mean")
abline(h = 0.05, lty = 2)
# for the uniformly most powerful test:
umpu = expon.umpu(0.05)
umpu.power = pexp(umpu$c, 1/th) + pexp(umpu$d, t/th, lower.tail = FALSE)
th = (250:1500)/1000
# for the two tailed test
power = pexp(a, 1/th) + pexp(b, 1/th, lower.tail = FALSE)
plot(th, power, type = "l", main = "testing for an exponential mean")
abline(h = 0.05, lty = 2)
# for the uniformly most powerful test:
umpu = expon.umpu(0.05)
umpu.power = pexp(umpu$c, 1/th) + pexp(umpu$d, 1/th, lower.tail = FALSE)
th = (250:1500)/1000
# for the two tailed test
power = pexp(a, 1/th) + pexp(b, 1/th, lower.tail = FALSE)
plot(th, power, type = "l", main = "testing for an exponential mean")
abline(h = 0.05, lty = 2)
# for the uniformly most powerful test:
umpu = expon.umpu(0.05)
umpu.power = pexp(umpu$c, 1/th) + pexp(umpu$d, 1/th, lower.tail = FALSE)
lines(th, umpu.power, col = "red")
th = (250:1500)/1000
# for the two tailed test
power = pexp(a, 1/th) + pexp(b, 1/th, lower.tail = FALSE)
plot(th, power, type = "l", main = "testing for an exponential mean")
abline(h = 0.05, lty = 2)
# for the uniformly most powerful test:
umpu = expon.umpu(0.05)
umpu.power = pexp(umpu$c, 1/th) + pexp(umpu$d, 1/th, lower.tail = FALSE)
lines(th, umpu.power, col = "red")
legend("top", legend = c("Power of equal-tailed test", "power of UMPU test"),
col = c("black", "red"),
lty = c(1, 1))
?pgamma
gamma.root = function(c, n, alpha) {
lower = pgamma(q = c, shape = n, scale = 1) # P (X < c)
# P(X < c) + P(X > d) = alpha
# P(X > d) = alpha - P(x < c)
# P(X < d) = 1 - alpha + P(X < c)
# d = F^-1(1 - alpha + P(X < c))
d = qgamma(p = 1 - alpha + lower, shape = n, scale = 1)
# return the equation to solve--> the latter half of the integral equation
return(pgamma(c, shape = (n + 1), scale = 1) +
pgamma(d, shape = (n + 1), scale = 1, lower.tail = FALSE) -
alpha)
}
?uniroot
eps = 1e-8
upper = qgamma(0.05, shape = 5, scale = 1) - eps
uniroot(f = gamma.root, lower = 0, upper = upper, n = 5, alpha = 0.05)
gamma.umpu = function(alpha, n) {
eps = 1e-8
upper = qgamma(alpha, shape = n, scale = 1) - eps
c = uniroot(f = gamma.root, lower = 0, upper = upper, n = n, alpha = alpha)
lower = pgamma(c, shape = n, scale = 1)
d = qgamma(1 - (alpha - lower), shape = n, sclae = 1)
return(list(c_val = c, d_val = d))
}
gamma.umpu = function(alpha, n) {
eps = 1e-8
upper = qgamma(alpha, shape = n, scale = 1) - eps
c = uniroot(f = gamma.root, lower = 0, upper = upper, n = n, alpha = alpha)
lower = pgamma(c, shape = n, scale = 1)
d = qgamma(1 - (alpha - lower), shape = n, sclae = 1)
return(list(c_val = c, d_val = d))
}
gamma.umpu(0.05, 5)
gamma.umpu = function(alpha, n) {
eps = 1e-8
upper = qgamma(alpha, shape = n, scale = 1) - eps
c = uniroot(f = gamma.root, lower = 0, upper = upper, n = n, alpha = alpha)
lower = pgamma(c, shape = n, scale = 1)
d = qgamma(1 - (alpha - lower), shape = n, sclae = 1)
return(list(c_val = c, d_val = d))
}
gamma.umpu(0.05, 5)
gamma.umpu = function(alpha, n) {
eps = 1e-8
upper = qgamma(alpha, shape = n, scale = 1) - eps
c = uniroot(f = gamma.root, lower = 0, upper = upper, n = n, alpha = alpha)$root
lower = pgamma(c, shape = n, scale = 1)
d = qgamma(1 - (alpha - lower), shape = n, sclae = 1)
return(list(c_val = c, d_val = d))
}
gamma.umpu(0.05, 5)
gamma.umpu = function(alpha, n) {
eps = 1e-8
upper = qgamma(alpha, shape = n, scale = 1) - eps
c = uniroot(f = gamma.root, lower = 0, upper = upper, n = n, alpha = alpha)$root
lower = pgamma(c, shape = n, scale = 1)
d = qgamma(1 - (alpha - lower), shape = n, scale = 1)
return(list(c_val = c, d_val = d))
}
gamma.umpu(0.05, 5)
gamma.umpu(0.05, 5)
gamma.umpu(0.05, 5)
gu = gamma.umpu(0.05, 5) # obtain c and d
g.power(gu$c, shape = 5, scale = th) + 1 - pgamma(gu$d, shape = 5, scale = th)
plot(th, g.power, type = "l")
abline(h = 0.05, lty = 2)
gamma.umpu(0.05, 5)
gu = gamma.umpu(0.05, 5) # obtain c and d
g.power = pgamma(gu$c, shape = 5, scale = th) + 1 - pgamma(gu$d, shape = 5, scale = th)
plot(th, g.power, type = "l")
abline(h = 0.05, lty = 2)
